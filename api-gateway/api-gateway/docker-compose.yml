version: "3.8"

services:
  # ------------------------------------------------------------
  # 1. EVENT STREAMING (Kafka & Zookeeper)
  # ------------------------------------------------------------
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    ports:
      - "2181:2181"
    restart: always

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      # Advertised listeners for Docker network communication
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
    restart: always

  # ------------------------------------------------------------
  # 2. APPLICATION DATABASE (Simulating RDS for Microservices)
  # ------------------------------------------------------------
  app-db:
    image: postgres:15
    container_name: app-db
    environment:
      POSTGRES_USER: ${APP_DB_USER:-postgres}
      POSTGRES_PASSWORD: ${APP_DB_PASSWORD:-postgres}
      POSTGRES_DB: ${APP_DB_NAME:-learning_platform_db}
    # No port mapping needed if only microservices access it
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${APP_DB_USER:-postgres}", "-d", "${APP_DB_NAME:-learning_platform_db}"]
      interval: 5s
      timeout: 3s
      retries: 10
    restart: always

  # ------------------------------------------------------------
  # 3. MICROSERVICES
  # ------------------------------------------------------------
  document-reader-service:
    build:
      context: ./document_reader
      dockerfile: Dockerfile
    container_name: document-reader-service
    environment:
      # Database connection URL (for Document Reader's persistence if needed)
      # We assume Document Reader needs a DB for document metadata
      DATABASE_URL: postgresql://${APP_DB_USER:-postgres}:${APP_DB_PASSWORD:-postgres}@app-db:5432/${APP_DB_NAME:-learning_platform_db}
      # Kafka broker URL pointing to the Kafka container internal network
      KAFKA_BROKERS: kafka:29092
      GEMINI_API_KEY: ${GEMINI_API_KEY}
      # The S3 Bucket Name used for storing documents and notes
      S3_BUCKET_NAME: ${S3_BUCKET_NAME:-document-reader-storage-dev}
    depends_on:
      kafka:
        condition: service_healthy
      app-db:
        condition: service_healthy
    # Exposing port for Kong to route to (not for direct access)
    expose:
      - "8000"
    restart: always

  quiz-service:
    build:
      context: ./quiz_service
      dockerfile: Dockerfile
    container_name: quiz-service
    environment:
      # Database connection URL
      DATABASE_URL: postgresql://${APP_DB_USER:-postgres}:${APP_DB_PASSWORD:-postgres}@app-db:5432/${APP_DB_NAME:-learning_platform_db}
      # Kafka broker URL pointing to the Kafka container internal network
      KAFKA_BROKERS: kafka:29092
      GEMINI_API_KEY: ${GEMINI_API_KEY}
      # The S3 Bucket Name used for fetching notes
      S3_BUCKET_NAME: ${S3_BUCKET_NAME:-document-reader-storage-dev} # Must use the same bucket name
    depends_on:
      kafka:
        condition: service_healthy
      app-db:
        condition: service_healthy
    expose:
      - "8000"
    restart: always

  # ------------------------------------------------------------
  # 4. KONG API GATEWAY COMPONENTS (Copied from your provided file)
  # ------------------------------------------------------------
  kong-db:
    image: postgres:15
    container_name: kong-db
    environment:
      POSTGRES_USER: ${KONG_DB_USER:-kong}
      POSTGRES_PASSWORD: ${KONG_DB_PASSWORD:-kong}
      POSTGRES_DB: ${KONG_DB_NAME:-kong}
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${KONG_DB_USER:-kong}"]
      interval: 5s
      timeout: 3s
      retries: 10
    restart: always

  kong-migrations:
    image: kong:3.4.1-alpine
    container_name: kong-migrations
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-db
      KONG_PG_USER: ${KONG_DB_USER:-kong}
      KONG_PG_PASSWORD: ${KONG_DB_PASSWORD:-kong}
      KONG_PASSWORD: ${KONG_ADMIN_PASSWORD:-kong}
    command: "kong migrations bootstrap"
    depends_on:
      kong-db:
        condition: service_healthy
    restart: on-failure

  kong:
    image: kong:3.4.1-alpine
    container_name: kong-gateway
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-db
      KONG_PG_USER: ${KONG_DB_USER:-kong}
      KONG_PG_PASSWORD: ${KONG_DB_PASSWORD:-kong}
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
      KONG_PROXY_LISTEN: 0.0.0.0:8000
      KONG_DECLARATIVE_CONFIG: /usr/local/kong/declarative/kong.yml # Load declarative config
    ports:
      - "8000:8000/tcp" # Proxy port
      - "8001:8001/tcp" # Admin port
    volumes:
      - ./kong.yml:/usr/local/kong/declarative/kong.yml:ro # Mount the config file
    depends_on:
      kong-migrations:
        condition: service_completed_successfully
      document-reader-service:
        condition: service_started
      quiz-service:
        condition: service_started
    restart: always

  konga:
    image: konga/konga:latest
    container_name: konga
    environment:
      TOKEN_SECRET: ${KONGA_TOKEN_SECRET:-super_secret_token}
      DB_ADAPTER: postgres
      DB_HOST: kong-db
      DB_USER: ${KONG_DB_USER:-kong}
      DB_PASSWORD: ${KONG_DB_PASSWORD:-kong}
      DB_DATABASE: ${KONG_DB_NAME:-kong}
      NODE_ENV: production
    ports:
      - "1337:1337"
    depends_on:
      kong-db:
        condition: service_healthy
    restart: always